{"pages":[{"url":"/pages/about-this-blog.html","text":"Since we Code Club is only once a week, this blog is a way to provide more detail than can be covered in each session. Hopefully the extra information helps those keen to learn more, and are excited to work on even more interesting projects.","tags":"pages","title":"About this blog"},{"url":"/pages/code-club-python-environment-cheat-sheet.html","text":"Last year our Code Club attempts with Python and IDLE were a bit frustrating. Well more frustrating than this year at least :). I noticed that a few things were a bit hard to read and didn't show up properly, so I've fixed those. So put this cheat sheet next to you while going through the Code Club Python activities. It relates to MacOSX, Windows, or Linux (we've used Raspberry Pis for our Dexter Industries BrickPi EV3, GoPiGo, and Minecraft Python sessions). Our environment uses three windows in MacOS and Windows: a text editor Python shell commandline terminal There's also some cool tricks for having multiple windows when connecting to Linux with ssh, which will get to in a later post! The cheatsheet gives examples to make us able to edit and run out Python in different environments. For those who didn't really manage to get much done during our noisy Code Clubs, or something just didn't work, have another go at home when it's quiet. As a few keen people have done, you can download Python 3 from https://python.org. That's probably the easiest to use. It also covers running your scripts. I think we're slowly getting better at troubleshooting Python errors :) I've put the updated cheat sheet here","tags":"pages","title":"Code Club Python environment cheat sheet"},{"url":"/pages/scratch-basics-roundup-slides.html","text":"I threw together a slide deck a while back, for our Code Club, to go through some of the Scratch command blocks we used during 3rd semester. We used this at the start of one of our sessions, and got the kids to explain what commands did, and when they would use them. There's a few at the end, that we hadn't used, put in just to keep it interesting and stimulate a bit of learning. Just in case it might be useful for other Code Clubs, I've provided a link to download it here .","tags":"pages","title":"Scratch basics roundup slides"},{"url":"/setting-up-your-raspberry-pi-robots-for-multiple-locations.html","text":"Using Raspberry Pi robotos in multiple locations If you run a Code Club at a location that you don't have access to during the week, you may already have discovered how important it is to have everything set up beforehand. This often means being able to communicate what you want to whoever looks after the computer network at your Code Club location. There's a few possible scenarios: Your location already has computers set up and connected to the network. In this case things are pretty simple, as long as you're just logging into sites with web browsers. As long as the network is up, you're good. You'll need a plan B if the network or Internet connectivity goes down. You bring your own network and computers. This is a fairly robust situation, except that you have to haul multiple computers around. All you need is power and heating/cooling to make things comfortable. Depending on whether you do things online or offline, you may need to have a place to save projects to. You have some online and activities going, but also have Raspberry Pis, robots, and some other hardware. Since our situation is the 3rd scenario, I'm going to write a bit about some of the challenges we've faced and try to share some tips for dealing with these so that your room full of kids doesn't revolt and eat you alive like a scene out of the Walking Dead. Hopefully this information will be most useful for those who are thinking of taking their Code Club the next level by adding a few more activities. A bit about computer networks If you bring your own network, you are most likely reasonably good with configuring everything, so you can skip this section. However, if you've been using an existing network so far, it's worth understanding network basics, so you can do some light troubleshooting and tell the IT guys when things are broken, or save your Code Club session by quickly fixing issues yourself. It's generally useful to underestand how things work on the network so that you can easily connect new devices to the network (if this is allowed at your location). If you're doing Code Club at a school, you probably will be allowed to connect other things. This YouTube clip is one of the simpler explanations of computer networks. It should give you enough of an understanding to know what information you need to get from the IT guys in order to set up fun stuff on the network. Connecting other operating systems to your Code Club network Some of the places where a Code Club is run will usually have one predominant operating system on their computers. This is likely to be Windows, Mac OS X, and some might have Linux. However, it's unlikely that there will be anywhere with all three operating systems. This means that one day, you may want to connect something to the network, that is out of the comfort zone of the IT guy at the school or library where your Code Club runs. At some point, it really pays to find a time to attend the Code Club location outside club session time. You may only have to do this once, and this gives you a chance to tee up a time to talk to the IT guy about how their network works, or anything that needs to be added/changed on the main computers you use. If you have Raspberry Pis or something that runs on an operating system that is not used at that site, you may have a volunteer who can bridge that gap between yourself and the IT guys when it comes to anything non-standard to that environment. Remember security and privacy u Keep in mind that network details are sensitive, and can let an unauthorised party connect to a network; so keep the main details like passwords secret and only talk in general terms if you're seeking help from an outsider. Preparing your robots Connect to your robot's IP address as the pi user, using ssh from the Terminal app on Mac OS X, or from Putty on Windows. Uncomment the following (by removing the â€˜#') in the /boot/config.txt file. Type sudo nano /boot/config.txt to edit that file. hdmi_force_hotplug=1 Use nano to configure the required wireless connections in /etc/wpa_supplicant/wpa_supplicant.conf o if you label each connection using the id_str = \"<name to identify location e.g. home>\" then you can use those instead of wlan0 in the file /etc/network/interfaces Here's where I found the information. However, if you have a portable network access point (AP), you'll want your rpi to connect to that in preference to others e.g. if you are at the school and your portable wifi AP is on, you might want your robots to connect to your own portable wifi AP rather than the school wifi. In this case, you can set a priority for each network in /etc/networks/interfaces using a line like priority = 2 where the configuration with the highest priority will be connected to first. Take your network with you for demos There's times when it really pays off to be able to demo things that have been created at Code Club. It really helps for parents, other teachers, and any other stakeholders to see value by giving a taster of what Code Club is about. This applies equally to other similar activities such as school maker groups. Although we have regular visits from parents, kids, and teachers, sometimes you'll be asked to present at a different location. This means you either have to: depend on the wifi at the location, meaning you will need to bring or borryow screens for your Raspberry Pis or figure out which address they end up with, etc. bring your own wifi AP and have the IP addresses of your Raspberry Pi robots set up in advance, and working 'out of the box'. Obviously the latter method makes for less things that could go wrong, since the only thing you're depending on is that there will be power. Even then, you can bring your own power packs. There's a few ways to set up your own network: use a wifi AP from your phone. This just means you have to make sure your phone stays near the robots during the demo. Usually, this means you'll have 4G Internet as well, which is handy for Scratch and other online activities. Just make sure you have sufficient mobile data to cope with Internet activity for your demo. purchase or find an old wifi AP device that you can bring along. This can often be connected at the location, as long as you've asked for this provision beforehand. Otherwise, if you only need a local network and no Internet, you're all good without plugging into another network. create a makeshift wifi AP from a Raspberry Pi and wifi adapter. I did this recently using a Raspberry Pi Zero and an edumax wifi dongle. It worked really well and was quick to do. This requires the following software: dhcpd (a dhcp server to give out IP addresses, and can support static i.e. always set ones that you know) and hostapd. The last piece of software needs to be a version that supports your wifi dongle so you might just want to search around to go this route. Here's one I set up for a demo recently. It took about 20 minutes but I've done it before. If you're tight on time, and aren't all that technical, go for the other options. Just remember that if you're doing robots without monitors (headless) then you want to be able to know what IP address they'll be using. If you're borrowing the location's network, you may need to port scan. Again if this doesn't make sense just ask someone more knowledgeable than you, like a technical volunteer. Configure the Nano text editor on your Pi If you're connecting via the terminal (using ssh or putty on windows) then nano is probably the easiest to use if you're new to Linux. You can set the configuration for the nano text editor. The options I use are: set mouse set tabstospaces Since set mouse will let you click on a line to go to it, and you can also hold down the alt key to drag-select some text with the mouse, then either right-click to select copy, or use the usual key combos e.g. command-c to copy and command-v to paste if connecting from Mac OS X, or control-c and control-v if connecting from Windows. Using set multibuffer allows you to open up multiple files in nano at one timeYou can look up information like this on stackoverflow.com Test everything beforehand Although you may think everything is set up exactly as it should be, it's important to test everything before doing things live. Since our Code Club is only one hour per week, if I mess up things, we have to wait another week until we can try again. This makes everyone sad and can give an inaccurate impression that the actual workshop itself is more difficult than it really is. If you're a teacher with limited technical skills, it works well if you can get a volunteer with those skills. When we first started, a previous student and I were the only ones to put up our hands to volunteer, but as things started to get rolling and peoples' circumstances changed, we have started to gather more and more volunteers giving us a wider spread of skills. It really helps to have a run sheet to follow with the robots. I found that if people ask questions that are in the run sheet, I'll point them back to that. This helps them stay on the run sheet and reminds them to read more carefully. Once they get focussed, things will speed up and at the end you'll be having to drag them away kicking and screaming, because they're having so much fun ;).","tags":"robots","title":"Setting up your Raspberry Pi robots for multiple locations"},{"url":"/scratch-brickpi-robot-workshop.html","text":"The robots At our Code Club, we currently have two robots both are made by Dexter Industries and are controlled from a Raspberry Pi . Our BrickPi robot uses a Raspberry Pi model 1B , combined with Lego Mindstorms more recent EV3 motors and sensors Our GoPiGo robot uses the same model Raspberry Pi, with one ultrasonic sensor a Raspberry Pi camera , and a servo that moves both Here's an photo from when we first put them together: This is before we added some of the extras described above. We chose Raspberry Pi-based robots, firstly because I had some Raspberry Pis spare, and donated them to our Code Club. Since the kids start with Scratch visual programming, having robots that can be programmed with Scratch capitalises on earlier pre-written exercises, and lets the kids know that what they are learning can affect the real world. Preparing for the workshops While programming the robots, we have 8 x AA batteries in a battery pack, with a micro USB power adapter connected as well. The motors require the battery pack to, and we found that we need the power to keep the wifi connection more stable when we are doing a lot of communicating with the robot. Once we have programmed the robot, we'll test it out, with the power still connected. Later when we have made the robot autonomous, we disconnect the power adapter, running it solely on the battery pack. A few useful tips from our experiences: have multiple battery packs so that you can swap a new one in if one becomes drained during the workshop rechargable batteries were easier compared to disposable, as we can charge them beforehand, don't need to buy more, and they have a more consistent running life than if we use different brands of disposables. it helps to get a charger that shows when the batteries are charged get a simple battery tester so you can tell which batteries need to be charged groups of two or three for one robot work better than larger groups because people are less likely to be left idle and distracted if the answer to a question is in the activity sheet, I let the kids know rather than just answering, so they keep their bearings in the activty sheet we normally record our progress with video and audio, then move on to the next step. There's something great about seeing the work on video. do enough testing beforehand to ensure that the robots connect to the network every time, and it can help to configure multiple connections, each with their own IP addresses If you've got a Code Club or similar, and want to run robot workshops yourself, you can download the student activity sheet I made here . I recently ran our teachers and volunteers through some training so we can run a few of these in parallel. We always start with Scratch, and then some kids will ask to do more in Python once they see what can be done. Using Python directly, allows for a lot more flexibility, since it is easier to interact with the Raspberry Pi e.g. speech or video streaming. Our robot workshops usually last for at least two sessions of one hour each. This lets the kids go through the activity sheet for the first session, and then plan out and add enhancements in the next.","tags":"robots","title":"Scratch BrickPi Robot workshop"},{"url":"/importing-more-python-functionality.html","text":"Python built-in functions and modules At Code Club our first Python scripts usually involve using built-in commands, otherwise known as functions e.g. print() , input() , int() . A list of built-in functions for Python 3 is available here . Sooner or later we might want to do something a little more interesting, like generate some random-ish numbers, or process some information in file, or connect to another computer. In some of the Python tutorials we've done, you'll notice the import statement being used to import more functions from the the Python standard library . An example of importing from the Python standard library: import random random_number = random . randint ( 1 , 1000 ) print ( \"Here's a random number: \" , random_number ) You could type the above Python code directly into the Python 3 shell or put it in a text file and called it something like print_random_number.py . We could run the latter in the Mac OS X terminal , in Linux e.g. on a Raspberry Pi, or in the Windows cmd.exe . To run it in Mac OS X, type: python -3 print_random_number.py Which results in: Here's a random number: 716 We imported the module, random , from the Python standard library. To run the function randint() from this module, we put the name of the module in front of it. This particular example will generate a random-ish (pseudo-random) whole number between 1 and 1000. If you looked at the Python standard library , you'll have seen lots of things to import for your Python scripts. Sometimes when we start learning to code, other people who can already code get excited and really want to tell you all of the cool stuff you can do. But if they did that, it could easily be overwhelming and make it look too way too complicated and hard to learn. But once you get a few scripts written and start to think of problems that could easily be solved by writing a script e.g. reading information from a website, processing it, and adding it to a spreadsheet. So...taking this import idea further, since Python is open source software , anyone who is interested in learning, can contribute additonal functionality to Python. What else can I do with Python? You can find a list of additional Python packages on this page . There's over 80,000 packages there, each containing functions that you can import into your scripts. Go to the 'list packages' link on the left to see all of them (be aware this can take a while to load). These packages can make it possible to useful tasks in only a few lines. This means that assuming your code is logically structured, you can create scripts that are much easier to read, and add to. This is important if you want collaborate with people, or have others use your code in their creations. To install these packages, a good way is to use a tool called pip or easy_install . On Windows, Mac OS X, or Linux if you're already installed Python from https://python.org, you can just download get-pip.py and run it with Python (it's just a Python script). Then you can just type pip search to find a package you want, and once you know the name of the package, type pip install <put name of package here> . Usually there are examples of how to use the package online. It's best to try the examples first, so you can get something that works, to help you learn to use the functions in your scripts. There are also a large number of Python projects stored in open source respositories like GitHub and BitBucket just to name a couple. When developers (people who write code) want to collaborate and share their code, they will store it in these type of respositories. This makes it easy for others to fork their projects, and either contribute using pull requests , or create a new project based on the forked project. So if you have a gadget that you're using an app to control, it might be interesting to search online for a Python script or Software Development Kit (SDK) that you can use to control it with, and understand how you can integrate it into your own projects. Many of these scripts that can interact with interesting hardware, come about from interested people observing how something works, and then figure out how to make a language like Python, send the same commands. This can allow you more control and flexibility than the standard app controls, and allow you to trigger the controls using other sensors e.g. using a Sphero to control a robot. Sometimes what is happening inside the case of electronic hardware can be much simpler than we expect. But we don't know unless we try to listen to control communications or search for information that helps us. This attitude of curiosity is something I like to work toward at our Code Club. Here's a video I found, by Paul McWhorter, showing how Python can be used to light up a Light Emitting Diode (LED) on a small Raspberry Pi computer. A few of the Code Club kids have installed Python at home. That's a good way to learn faster and more often, since it can be hard to learn quickly if you have to keep backtracking. Python is great because it's free and easy to write scripts without a lot of boilerplate code. Boilerplate code is lines of extra code that need to be added before you can start coding in some languages. It's nice that Python doesn't need too much of this, and because it recognises indentation, it's quite easy to see the structure of Python programs. This makes it a lot quicker to follow what is going on, and partially why we're starting with it. A really good exercise when learning to code, is to go through someone else's Python script and try to figure out what it does. Then if you get stuck, go and ask someone who knows a bit more, and get them to walk you through the parts that don't make sense to you.","tags":"python","title":"Importing more Python functionality"},{"url":"/text-editors-and-helping-kids-learn-python.html","text":"This post is primarily about some of the discussions we've had about facillitating Python coding at our Code Club, some of our experiences as a Code Club, and some of my ideas about what the kids can use Python skills for. Dealing with a variety of different operating systems for a variety of different projects, I try to use whatever tools are available on the platform we're using, and do the job. Although it might take a little bit longer to get the hang of things, and sometimes it's not all as straightforward as we'd like, it means we end up being a little more adaptable. We purposely use tools that are free and open source, or that come with the operating system, whenever we can. e.g. there's been times when we've just use notepad on Windows, or nano in a Mac OS X terminal, or when connected to a Raspberry Pi. This gives more flexibility since we can add our own modifications if required, and makes them readily accessible for kids to be able to replicate things at home. I think that is really in the spirit of learning to make our own code creations, and contributing to improve things as we go. Also, when we initially used the Python IDLE tools, the kids were getting a bit confused, until we were able to explain that Python scripts are really just text files. We played with Tinker for a short while, although for it seemed like it abstracted Python and HTML away from being able to interact with real things. Some kids seemed frustrated that they couldn't easily upload their own image files, and we couldn't import other Python packages. Since we've already talked about web sites, applications, and robots that use Python, it makes sense for us to be using Python in a context where this seems more accessible. Likewise, although sometimes we will start looking at devices like the Sphero, that are initially controlled with an app, I've had some great discussions about what's really happening behind the scenes. Once we understand how things really work at a low level, it's great to try and write some code that will allows us to control things directly. I remember a friend at school once saying that while coding sounds good, \"it's all still just on a screen\". Interestingly, that friend does spend a lot of his work time sitting in front of such a screen. The really exciting thing about having Raspberry Pis connected to arduinos controlling robots, is that suddenly not just stuck in a computer screen, we're affecting the world around us. One of our students last year mentioned that he had initially thought coding was only about games, and during Code Club, had realised that it meant he could make all manner of useful inventions that were driven by code. Some issues we come across when using a variety of editors include: sometimes the lack of line numbers can make us work a little harder to troubleshoot our scripts we have to understand the basics of how to get around without a mouse at times linefeeds in a file taken from one operating system can look like rubbish in the editor of another operating system we get less information while typing in our code the more basic editors don't recognise that we're writing Python, so they don't highlight important parts of the commands (syntax highlighting) so we actually have to know what we're doing...eventually I'd forgotten the Atom editor until recently. I used to use it just for HTML and style sheets, but then I remembered it can work nicely with Python, since it recognises it and fixes most of the above issues (we'd still need nano in a terminal). However it is supported across Windows, Mac OS X, and Linux (not so much on the Raspberry Pi at this stage). It is also really easy to install, by just grabbing a .dmg file for Mac OS X or an installer for Windows, and so on. This possibly makes it a lot easier for Code Club teachers and volunteers to install on their own systems. Although I suspect that there will be some point where we will need to show how to install pip and grab the Python packages we need. You can install the Atom editor by following the instructions here for your operating system e.g. Windows, Mac OS X, or Linux.","tags":"python","title":"Text editors and helping kids learn Python"},{"url":"/tips-for-designing-your-first-scratch-games.html","text":"The idea Our Code Club is part of Code Club Australia who provide some great resources that include some fun Scratch game tutorials/exercises. When kids are new to Code Club, the best place to start is by doing several of these step-by-step activities. Sooner or later the kids start to get some ideas, and start designing some of their own game ideas. It can be easy to stay within the safety zone of what we've done previously. Sometimes that happens, and while it is a nice and easy way to spin up a working project, soon we find ourselves thinking up more complex ideas and jumping straight in to build them. Although there's a lot of tutorials and videos out there that show how to make something by following step-by-step, this post is more about the process of going from a idea to a working Scratch game. Ok, and on with the post.. Getting more out of Scratch Once we get to the point that our code gets complicated, it can be easy to lose track of what does what. At this point things can get overwhelming. It can seem like programming is a brain-melting pursuit, and it becomes frustrating, or just a whole lot of work to make our game do what we want. In this day of many distractions, it can easy to give up, move on to something else, go and watch cat videos. Although if you actually want to learn something, it might be better to go and watch a Scratch tutorial, like some of Al Sweigart's , which are well-paced and engaging. At Code Club it can also help to go and do some more exercises. Sooner or later, we realise that there are much easier ways of doing what we want, and this can make our code seem simpler and clearer. Maths is a great analogy when you think about how hard it was to do various calculations, until you worked out all these ways of visualising things in your brain, and it became much simpler. It is always great when I come across someone who looks a bit frustrated, only to see their face light up when you explain an easier way to do something. A good resource can be other Scratchers, who post tips and answers to questions in forums, or make demo Scratch projects. You can look at their code, and compare it with other similar projects. Here's an example of something that really helped me; at some point, I realised that once I created a working character, I could drag the scripts create enemies, and then use clones instead of lots of sprites, to populate my game. Before that realization, I'd find myself using way too many sprites, and thought that Scratch was so much more limited than it really is! So some of the concepts that help us at this point are: there's usually multiple ways to do something, and knowing the best way that is easy to understand and read, can allow us to make more interesting and easy to manage games without getting overwhelmed if something doesn't make sense, we may need to see it explained in a different way Solving problems and debugging Often, I see a common cycle of enthusiasm -> frustration -> problem solving -> satisfaction. When we start Code Club for the first time, a lot of us need to put our hands up when something just doesn't work. As we progress through the activities, we get to know some common mistakes that we make, and later we actually start to use tricks like showing variables or printing values to the screen to figure out why something doesn't work right. That last point is really important, because eventually our code, which may now be easier to read, more elegant, and simpler, can still be complex enough that some of these tricks are useful in determining what is going wrong, and where it is going wrong in our code. I put together a document during last year's Code Club, with a few ideas for troubleshooting Scratch bugs. You can grab it here . When I see kids getting to the point of comparing code from one game to another, or putting it isolating it in another project, or just tracing through their code, to successfully solve problems, it is obvious that they have grown from just typing in someone else's code, to actually understanding what is going on. There is a certain clarity that comes with this, and often we can visualise in our mind, some of the ways we could make something work. There is a certain level of maturity in our thinking when this happens which is both exciting and empowering. Recognizing patterns and models So guess what? In order to keep getting better at coding, and increase how fast we can create, we need to continually put ourselves though this process of attempting to do something, running into a problem, and solving that problem. That's practice, and in the same way that other activities required more energy at the start, until we mastered them, coding gradually gets easier too! And something that happens as we go through this cycle of solving problems and learning, is that we start to recognise patterns. Some example of patterns might be a common way to implement controls for a player, creating gravity, adding lots of game levels without needing so many sprites, wrapping the player to the other side of the screen when they reach the edge, and so on. Once we see these patterns and implement them in our Scratch games, it's important to start keeping a library of these. Doing this will make it much faster to pgrogram lots more games in Scratch. A great way to collect short snippets of useful code is by using the Backpack feature. The Backpack can be found t the bottom of the screen when you log into Scratch online. There is a label at the bottom, with an small arrow to view it. By dragging yours or other Scratchers' code snippets into the backpack, you will have read-made code to drag into your project. How good is that? You can probably see the time this would save. In addition to storing code snippets, the Backpack can also hold sprites and images. A good use for this might be some key animation frames, or favorite custom backgrounds. Although you can upload these too, having them online means you're not tied to your home computer or one you may use at school or an office. For more involved features you might need to just hang onto the game you created previously, as reference for something that took you ages to work out. Sometimes this could also be a trademark feature that makes all your games instantly recognizable. Have a clear plan with milestones Often I like to ask our Code Club kids to tell me about the games are creating. Many times when we get into this conversation, they can tell me a few details, but are unsure of the whole concept of the game. If we had an initial plan, we can usually go back to that plan, and compare how our coding is going. By having a plan, we can check whether our game works as designed, or if something needs to be changed. It also makes it easy to measure our progress. Sometimes game designs can be entires storyboards, with lots of different 'states' or possiblilities. However, in Scratch, it is best to keep our plan to a simple single sketch, wiht some words to outline what happens in our game. At the point where we draw up our first plan for our game design, we need to keep it really simple. This is so we can focus on getting the basic mechanics of our game working. It's easy to get a bit ambitious at first, only to find that our idea requires a lot more thought, so to start off, just keep it real simple. I noticed one of our Code Club kids has been creating what's called a changelog for each version of his game. A changelog is a record of the changes that have been added to each version of the game. That way, you can go back to the previous version instead of right back to the start. With each feature we add, we can set ourselves a milestone. A miltstone in this case, is a previously-defined point that we see as our next goal. An example could be the implementation of a new feature. So the point at which that feature is working, would be our milestone. It's a really good way to keep track of our projects and to help us work toward small goals as we add features and enhancements to our game. So let's say your initial plan for your game design is a bat that flies around on its own, and your player has to dodge it. Pretty easy to do, right? But once you have this done, then you could add extra enhancements. Examples of these could be: a time limited scoring system that resets at the end of each game, when a set amount of time has passed a menu to allow different options to be set, with each option being a separate milestone as well mulitiple levels, with the backdrop and number of bats increasing with each level bonus objects that allow the player to swat at the bats ..and so on. Here's an example of a plan I made. It's probably a bit more ambitious, and I ended up simplifying it, as some components ended up not really being required. And here's what it ended up looking like. As you progress with Scratch games, you'll start to find that you can make your initial plan a little more complicated, because you can use your previously-saved snippets to make building it easier. Just try and start with something simple as it is more satisfying to have a completed game than several projects you didn't finish because of lack of planning. I've made an infographic summary of the process here .","tags":"scratch","title":"Tips for designing your first Scratch games"},{"url":"/saving-scratch-game-states-to-cloud-data.html","text":"How do I allow users to save a game state in online Scratch? One of our Code Club kids asked this question last week. So I worked out a simple way to do this. In order for this method to work, you will need to have been upgraded from a New Scratch member to a Scratcher . This will allow you to create up to 10 cloud variables, with each able to contain 10,240 digits. During a game, we use variables to keep track of things like: the player's score what level the player is up to objects or trophies that the user might have grabbed during the game There's also some variables that are automatically set when another Scratcher plays your game, such as username. The idea would be as follows: when the game is run, the cloud data is loaded from the Scratch servers, and stored in a list. When the player hits a specific key during the game, the score, level, and other information at that point, is added to the list. Later, the list is written back to the cloud data variables, and so on. This was done pretty quickly, and made it as simple as possible to demonstrate the idea. You can look up two more complex examples at the Scratch cloud data documentation page . It's also possible grab various variables such as username from the Scratcher's profile, or encode data stored. I've left these, and apply this to a full game, as an exercise for the reader. For this tutorial, I've used just two single-digit variables, but it's not a huge leap to store multi-digit or alphabetic data fields as well. Required functions I've set up the following actions (functions): intialize: set the pointers, counters, and cloud variables to empty values load: load the data, from the cloud data variables, into a list save: overwrite the cloud variables with data from our list input: allow the user to enter 20 pairs of digits to be stored as cloud data (you could also input to the list, and then use the save action to write to cloud data) For all except the input function, I've use a custom block that is set to run in turbo mode. This makes things a bit quicker. Then custom block is called when an assigned key is pressed. This is the initalize code (the player presses i ): This is the load code (the player presses l ): This is the save code (the player presses s ): This is the input code (the player is prompted for single digits - this is only for the tutorial, since normally this would be generated by the game): Add these scripts and blocks to a single sprite and run it!","tags":"scratch","title":"Saving Scratch game states to cloud data"},{"url":"/preparing-sd-cards-for-our-code-club-robots.html","text":"Writing SD cards on Mac OS X There's a few different ways to do this on the Dexter Industries site , and this is post just shows a process that worked for the workshops we do at our Code Club. It may be useful for those running Mac OS X with homebrew installed. Homebrew is an easy way to install and manage open source software and other software, on the Mac. Install a tool to unarchive .rar files e.g. unrar: brew install unrar Unarchive the downloaded archive: unrar e 2015.03.20_Dexter_Industries_wheezy.rar Then identify which device the SD card is: Here, the SD card is at /dev/disk5 . The command to list devices is diskutil list . Do this before then after inserting the SD card to see where your device is. If the device is mounted, you need to unmount it first with umount diskutil unmountDisk /dev/disk5 You should see: Unmount of all volumes on /dev/disk5 was successful. Next, writing the SD card is performed with sudo dd bs=1m if=2015.03.20_Dexter_Industries_wheezy.img of=/dev/disk5 . The image name here was the latest version at the time, so will be different for yours. At the time of writing, it was available for download here but refer to the Dexter Industries page for the latest. Writing the SD card is performed with sudo dd bs=1m if=2015.03.20_Dexter_Industries_wheezy.img of=/dev/disk5 Now is a good time to go and grab a drink, and a quick bite to eat. On Mac OS X, you can use the control-t key combination to see the time remaining for the write. Boot it! ..and it works! Well, once you put it in the Raspberry Pi and boot it, that is. Configure, backup, then write to other SD cards Of course by this stage, you'll want to go and talk to whoever sets up the wireless, and find out how to configure your Raspberry Pi to the Code Club network. Since Raspbian for Robots is a custom version of Raspbian for Raspberry Pi , your mileage may vary at this point. Refer them to the links in this post and they should soon work it out. Or, just read up on it yourself. Once I had the SD card configured and tested, I backed-up the SD card with (replace disk5 with your device as identified above), dd if=/dev/disk5 of=backup_filename.img bs=1024 . Depending on how you set up your networking, you may just need one SD card image, or multiple set up for different IP addresses. Use the same command used to write the image the first time, but replace the original Raspbian for Robots image with the one you've just backed-up to. To simplify things when you suddently realise that it's Code Club time again, and have to grab everything and run, make sure you clearly label which SD card is which. As we do small group robots workshops, I usually try to have at least one SD card ready for each group. I also have different ones for the BrickPi and GoPiGo.","tags":"robots","title":"Preparing SD cards for our code club robots"},{"url":"/fun-times.html","text":"Redesigning our fun Although I wrote about the Python side of today's session at Code Club, it's worth talking about everything else. Since we'd had the couple of weeks off, we took this opportunity to take a breath and look at how we could get everyone excited again, and improve a few components. A few observations from previous Code Club sessions this year: It worked better when we used our round tables for Python, rather than last year's outward facing seating We ultimately wanted people to offer enough activities that kids could choose - People seemed more focussed when we had defined areas in our open plan set up for each activity People seemed more comfortable when they could see what others were doing, and not feel tethered to only one What we did today Today was set up like this: We worked together on Python (Python Challenge and Code Club activities) at a block of stand up tables Nearby, in the middle of the space, we had Spheros running through a huge made made of icy pole sticks..and sometimes all over the place too! People were designing on TinkerCAD and we looked at each other's 3d creations, and printed something Scratch projects were still progressing, and people could shift between activities so they got a more varied experience We talked about the upcoming STEM and Scratch video game competitions Although we were down a volunteer and a teacher this week, something about the excitement and choices actually seemed to make things seem more relaxed, more exciting, and actually quite a bit better focussed too.","tags":"scratch","title":"Fun times!"},{"url":"/python-progress.html","text":"Today was a great Code Club session. Some of us have been finding the Python progress a bit slow so far, with not much reward, with some concepts seemingly hard to grasp. And that's fair enough, because text-based tic tac toe, or trying to say that older adventure games are fun, really doesn't compare to the cool feedback of an iPad or the more visual games we create with Scratch. So turning it all around today, we dived into the Python level-based challenge that I came across last week. It was also a good time for it as due to other school activities, we've been away for 2 weeks. We had a new person over in the Python group, and he was working through some a Code Club Python exercise. Meanwhile, a few of us sat down and put our heads together to start solving the Python challenges programmatically. I may be painting this as a quiet, focussed session, so I'll also add that tons of stuff was going on at the time. It was pretty chaotic, and for some reason that made it more relaxed, and also awesome at the same time. Numerous times, Sphero balls would run into my feet, and elsewhere someone was printing a tiny bear. The importance of keeping our work became more obvious today, as we were able to go back and reference previous Code Club exercises to help us solve some challenges. In both Python activities, there were some good breakthroughs. We don't always get it the first time, and sometimes that's what helps us learn things. I can think of at least 20 things that didn't work today, and each time one of us would notice something, that led us to figure out the answer, and keep moving on. I got the impression that a few kids surprised themselves by solving some of the Python errors, while trying to get to the next level. Something that seemed to take away the pressure with our Python progress, was that we were fine with people moving around to spend time on whatever they wanted.At the end of the session, we'd worked as a team, and in parallel, and learned how to think on our feet, apply new concepts, and were rewarded by solving a few of the challenge levels. It's great to hear the emphatic \"YES!\" of accomplishment once again.","tags":"python","title":"Python progress"},{"url":"/scratch-stencyl-and-video-game-programming-competitions.html","text":"Game creation platforms we're currently using at our Code Club We've seen a few great games coming out of Code Club. So far we've been using Scratch but we also have a class set of Stencyl licences. Stencyl isn't covered by Code Club, but there's some lessons to get started here . Differences between Scratch and Stencyl Scratch has a simple interface, making it quite a lot easier to get started with for those who haven't programmed before. Scratch doesn't need to be installed, since you can sign up online and access it with a web browser. This is probably the best choice for kids to start coding, and the advantage of a Code Club is that there are lots of activies ready to go. Sitting with others at a Code Club can also make it easier to learn from each other, and teachers or volunteers. Scratch can also be used to control physical devices. We use Scratch for our BrickPi robot. Although both of these programming platforms are visual, Stencyl makes it easy to create larger and more complicated games, and has the advantage of allowing games to be pushed to mobile devices and app stores, including Android and iOS devices. There's also a free version to get started with, and this still allows the games to be played in a web browser, or hosted on a website. Unlike Scratch, that lets you create online and share a link to a game, putting a Stencyl game online requires some sort of web hosting. The popular Impossible Pixel game was written with Stencyl. There's some really good books available for both of these programming platforms, as well as online video tutorials on YouTube. Australian game programming competitions Since our Code Club kids are starting to create some interesting games, there's two competitions in Australia that may be interesting. Code Club Australia Scratch Day competition will have winners announced on Scratch Day, 14 May 2016, with submissions closing at 12 AM Thursday 12 May 2016. Australian STEM videogame challenge is a national competition open to all Australian students in years 5-12. Registration is open now until June 2016, with game submission from 7-19 August inclusive. These are both great opportunities for young coders who are interested in submitting their games! Click on the links above for more information. Parents' permission is required to enter these competitions.","tags":"scratch","title":"Scratch, Stencyl, and video game programming competitions"},{"url":"/setting-up-robots-for-code-club.html","text":"I thought it'd be interesting for our Code Club kids to see behind-the-scenes, and for other Code Club teachers/volunteers to see our process. Firstly, there's some really good information provided by Dexter Industries , who make these robots. I've pulled this post together from notes made at the time. This post covers the first few steps I went through last year, setting up the GoPiGo robot. Since we have done a bit more Python this year, the aim will be to program this with Python, and our BrickPi robot will be programmed in the older offline version 1.4 Scratch. Both these robots are each driven by a Raspberry Pi 1B computer, connected to Dexter Industries boards. We use 12volt battery packs to power these as well as motors and sensors. I'd recommend having them plugged in when programming, since it prevents the batteries from being used as much. One issue I had with the BrickPi out of the box, was that the power connector for the BrickPi board was connected with reversed polarity. This was obvious when the batteries became really hot as soon as they were connected. Quickly disconnecting the battery pack, I checked the documentation and once I had corrected the polarity, everything operated correctly. Anyway I'm getting ahead of myself. Last year we bought a BrickPi board to control our existing Lego EV3 motors with Scratch and Python. The grade 6 kids were divided into teams for a number of robot workshops. In this era of many distractions, a simple inforgraphic was a good way to show a high-level idea of how it all sits together with the BrickPi. An issue with setting up VNC at the time was fixed using this . Since then, Dexter Industries have implemented an easier way to connect to the BrickPi and GoPiGo via the browser. For the workshops, we started by looking at the example Scratch code that comes with the Dexter Industries robot operating system (robotOS; a modded version of Raspbian). From this, we would discover what 'broadcasts' need to be sent from Scratch to the Python script in order to: move forward and back turn left and right using a few different methods stop and start One script that comes with robotOS is the 'car' script, which allows the robot to be controlled from the keyboard. Since our BrickPi motors are mounted upside-down for a lower centre of gravity, the first task was usually to correct the forward and backward controls. Lessons we'd learned with Scratch activities come in handy when we look at replacing the interactive controls to use a script to control them. Once we got to this stage, we needed to read data from the EV3 sensors. This was a bit of a problem as we were never able to get the sensors working properly. Over the holidays, I looked into this and found that we needed a firmware upgrade for the BrickPi to use the EV3 sensors. Again, a script on robotOS assisted with checking the firmware version. After successfully doing the firmware upgrade on the BrickPi, it became apparent that the Python script, that listened to our Scratch broadcasts, was only sending the commands for the older Lego Mindstorms motors. Looking further into this, I found the required commands in some other example scripts on robotOS, and added these to an modded version of the original Python script. Since I've been pulling this together from my notes, I'm gradually adding to this post as I go. As other Code Club volunteers and STEM teachers can probably attest to, it is not uncommon to get something working the night before a session, and updating documentation at odd hours. Take this as a rather live blog in that sense...","tags":"robots","title":"Setting up robots for Code Club"},{"url":"/exciting-scratch-projects-are-happening.html","text":"Over the last couple of weeks, I've been able to see a few great Scratch projects that are being build at our Code Club! This year it was great to have everyone sign up to Scratch before our Code Club started again at the start of this year. By doing this, it meant that we were mostly all working online, which gave people the opportunity to keep working on things at home, rather than waiting for the next Code Club. A few of us had already started playing around with Scratch before Term 1, and some of use has also been using Scratch previous in grade 4 classes. Even though term 1 was a bit shorter than the others, we were still able to get a few activies under our belts. I tried to choose some of the ones I remembered as being popular and interesting last year. Starting off with Lost in Space, was a good introduction as it teaches about positioning, rotating, moving, and resizing sprites. In simple terms, sprites are images that we can move around, make appear and disappear, collide with one another, and many other actions. After a few weeks and few more activities, the Scratch kids got a chance to make their own game. Interestingly, when I asked who had already had a go at making their own games, several people put their hands up. One of our members had already made a complete game which he demoed to the group, having another member very eager to volunteer to try the game. At this stage, everyone was pretty keen to get started. This involved working in pairs or solo, desiging the basic game on paper. It was interesting to learn more as we came across problems to be solved, while completing our goals. We continued working on our games on the first week back after holidays. It was great to see that quite a few people working on their projects before coming back to school. One pretty awesome game I saw had multiple levels and was completely finished! Although we having a break this week, next week we'll be right back at it, and it'll be interesting to see what people have come up with. We're trying to keep track of where everyone is, and hopefully we can help each other to get lots of projects completed so that we can showcase these to friends soon. I will be good to get some screenshots online as well.","tags":"scratch","title":"Exciting Scratch projects are happening"},{"url":"/python-level-based-challenges.html","text":"Looking through various Python tutorials that are online for kids, I can kind of see why some of the initial rewards can seem 'boring' to kids who are being lured by the pretty graphics and animations of modern tablets. Coding challenges and Capture The Flag (CTF) team competitions have always seemed a bit more exciting than talking about text-adventures sometimes. Although we're probably not up to CTFs or the Google coding challenges that are running, I came across a fun level-based Python challenge , written by Nadav Sanet , that just happens to align quite well with our Code Club activities. ;) The idea behind this particular challenge is: solve the problem by writing a Python script get to the next level web page solve the next problem ...and so on. I reckon this will be loads more fun because writing the script actually leads to progression in the game itself! It also lends itself to teamwork, and I can drop clues as we go. Hopefully this will be tons more satisfying to work through from week to week, and will also get us thinking a lot more to solve a problem and see how far we can get. Last year we had some good competition building up between groups working on the robots, and with our quiz. This may help tap into that energy again, while showing how various components work together. So before we start, here's a screenshot: I'll let you know how it goes... :)","tags":"python","title":"Python level-based challenges"},{"url":"/spyder-python-ide.html","text":"Tools for writing Python An Integrated Development Environment (IDE) is software that integrates tools for programming. As we've seen, for Code Club, the basic tools we need for kids to program in Python are (assuming we've install Python): - a Python shell to try out commands with immediate feedback - an editor, with a simple interface, to create Python scripts containing our code - an environment to run our scripts that gives us errors when we make mistakes Other features, I see as optional, but useful include: - syntax highlighting, where our code is colour coded to make formatting mistakes more obvious when editing; - auto-completion, where the editor helps us a bit by suggesting commands that might be useful (I think this can be a little confusing when just starting); and - a debugging interface that can let us stop, or single-step, our code while it is running, so we can find where our script might be going wrong. Our first experiences at Code Club When we first started doing Python activities, the main problem that came up was kids getting confused as to whether they were in a Python shell, editing, or running their code. Once we explained that their script was just a text file, and that they could edit it in something as simple as notepad, things became a little easier. Some of us had a bit of an issue with typing things out, so it was good to run code often and see things happening. Some of us preferred Windows and some preferred MacOSX. That's where the Python cheat sheet (see the link above) came from. Something to try As we have a mixture of netbooks, macbooks, and imacs, and 3 Raspberry Pis, the environment we've been writing our code in varies. Being a bit of a nerd, in an effort to make sure we at least do something during our Code Club session, I'll often just use whatever text editor I can find to write Python. Sometimes this includes the nano editor, which I'm sure everyone gets a bit frustrated with, but I firmly believe will help us be more adaptable when we don't have a pretty graphical interface. I'm sure this drives people a bit mad ;) but hopefully it's all good when the code eventually runs :). After all this rambling on, the main point is that I tried the Spyder Python IDE (Scientific PYthon Development EnviRonment) recently, and it seems close to what we need. Personally I like things like Wing IDE but for teaching kids we just need something simple, where they get the main tools listed above. Spyder seems to run on the operating systems we encounter, and unlike some of the other tools, has a more intuitive interface for kids. It also has syntax highlighting and tells them what version of Python they are using. To me, it's important that people have a tool they can use install and use at home, since Code Club is only one hour a week for us. Anyway, it looks like this: If you'd like to try it, there's instructions for installing Spyder version 2 here","tags":"python","title":"Spyder Python IDE"},{"url":"/keeping-what-youve-learned.html","text":"I used to scribble a ton of stuff in the back of one of my old Commodore64 manuals. Whenever I'd find something cool in a magazine or book, or later, text files, I'd scrawl it in. There was something about it being a bit messy that made it easier to remember. These days, there's a ton of different ways to do that online or in files, but most smart coders I know just go and look up their own code. i.e. things they've done previously. One of the coolest things about working out a good way to do something in code, is that you can go back whenever you need to do that. A classic example could be a script that reads lines from a file and makes some change to every line, before writing out a new file. That's the type of thing that you'd probably find yourself wanting to do for lots of scripts, so you'd probably keep that script. You'll probably keep improving the script as you get better at coding and come across more 'gotchas' that can be avoided by wrinting better code. Another way of remembering things is to recognise and remember patterns, or idioms. Idiomatic Python has been a really good reference for getting things done in Python, using consistent and practical structure. It's not the only way to do things, but has some logic reasoning behind it. Although there's a ton of information on the Internet, there's also a lot of bad information, so you really have to sift through to find the good information. And before you ask questions on forums or places like Stack Overflow , make sure you've put some effort in and done some hard searching first. People tend to help those who put in the work, rather than those who ask before trying. And if this doesn't work, sometimes the edited structure of a good book can be very helpful as well. Something that will also help, is to just keep at it. Forcing yourself to push through tough problems and finishing projects will really train your brain and make things a lot easier to learn in the future. Collaborating can also be a great way to learn, since the load is spread over more than one person, and decisions are sometime easier to make as a group.","tags":"python","title":"Keeping what you've learned"},{"url":"/moving-from-scratch-to-python.html","text":"So going from visual programming like Scratch to a text-based language can intially seem a bit lame. Yep, that makes sense to me. We've just gone from something that lets us drag blocks into a window with spinning monkeys and bouncing balls, to...typing words, that makes a few words come up on the screen, or draws a boring star. The other thing that made this change kind of suck, is that things don't work nearly as easily as Scratch does, at first. So some of the annoying things that have slowed us down include: laptops having the wrong version of Python on them, so we had to change our code or the commands to run things IDLE being confusing or not running having to edit things with weird editors AND WHAT ARE THESE CRAZY ERRORS!!!?!??? Scratch didn't have these!!! Our grand plan is that we have a heap of different activities running at one, and people can choose what they want to do. The only thing we need to remember with that plan is that we need to show parents and teachers that we're making cool stuff, learning, and having fun. So keeping this in mind, we wouldn't be going through all of this if Python wasn't helping us make cool stuff and having even more fun...eventually. It's pretty easy to do fun stuff with Scratch because we move things and see if the collide.. and w00t we have a game! And even though we can use Scratch to do things like robots, and make lights go on, there are limitations. We have Stencyl, but more about that in a later post ;) As for Python, even some teachers have been asking what it can do. We know it can do crazy things that seem a long way from our simple scripts, but here's some uses that only require simple scripts: read web pages and extract information we want, then do things with it make a script that waits for something to happen, say if someone triggers a sensor or touches your computer, lock them out andrecord them with a camera and then email it to you make robots do interesting things, like stream video to a website, balance on 2 wheels, detect faces, analyse writing from a photo and speak it, understand its surroundings and avoid or pick up objects create chat bots that pretend to be human and interact with social media automate repetitive tasks, such as renaming lots of files, or converting large amounts of audio files to another format, or sorting and converting videos based on a particular attribute such as date or name decode information from radio signals, such as airplane coordinates, and plot them on google earth extract geographical information from photos and see where someone has been at given times this blog uses software written in Python to generate all the web pages among some of the software built with Python are some great artificial intellingence tools that can be integrated into other projects To sort out the details of trying out commands, editing, and running out Python, I put together an updated-from-the-other-day cheatsheet A big advantage of learning to code in Python is that we don't have to worry about a lot of complicated syntax (rules for formatting the code) or extra code to make it work. It runs on many more things than Scratch does, and can do much more complicated work and still have simple, readable code. And once we know a bit about Python, there's a whole lot of extra modules available Understanding a programming language means you can have an idea, but actually make it.","tags":"python","title":"Moving from Scratch to Python"},{"url":"/cloning-sprites.html","text":"Someone asked me about duplicating a ball, that would drop down for the game character to dodge.. One of the concepts we looked at last year in Code Club, was creating lots of instances of one sprite. In the simple zombie game I made, this was an easy way to spawn a ton of zombies as the game progresses. At first, the obvious way to do that is by creating lots of sprites. But that's probably a bit too much work. Boooo!! An easier way would be: If something happens, clone a sprite. When a clone is created, do things (like make balls move downwards until they hit something). An activity I looked at for Code Club last year uses clones. It's called Catch the Dots . The game itself is pretty good fun to play too! As for doing gravity to make things fall, Al Sweigart explains it really well in his series, InventWithScratch: Oh, and did you notice that he has a cool tip for running certain parts really fast?","tags":"scratch","title":"Cloning sprites"},{"url":"/term-1-python-roundup.html","text":"In term 1, grade 6 people who were in Code Club last year, went through some Python concepts. The activities we had a go at were: Using a text editor e.g. notepad, in Windows, we went through the inventwithpython guess the number exercise. We discovered that the Macbooks' Windows defaulted to Python 2, which we later fixed by running our scripts from the cmd prompt using: py -3 <ourfile.py> . Some people had a go at copying and pasting the code and soon found out that this changed formatting as well as copying the line numbers. In some ways, this was more work because line numbers had to be taken out, indenting had to be restored, and carriage returns needed to be re-added. Our Python coding (development) environment at this stage consists of: A Python shell that allows us to type in interactive Python commands, to see how things work before putting commands into a script. Later this was especially useful when using the Python turtle module. A text editor. We used text editors because, previously, we'd had varying success with IDLE and Tinker. It was a little confusing to easily see the difference between the editor and shell when loading scripts in IDLE. In Windows we used notepad because it's already there, in OSX we used nano from the terminal. Nano was useful when we later connected to the Raspberry Pi using ssh to build things with Python Minecraft Pi module functions. This is also useful since we also have some robots that we run with model 1B Raspberry Pis. A command shell/window. We ran out scripts after running cmd.exe to get a command window. Later we found that it was easier to just save our scripts, but keep them in the editor, so that we could easily make changes to fix errors or add different code. Code Club turtle activities. This time we discovered that the netbooks running Windows did not have Python3 at all. So we ended up trying to do things in the Python shell, but it was a frustrating session. A few of us ran some of the turtle scripts, which didn't need Python3. The initial idea of this session was to build on the previous 'guess the number' activity by adding loops and introducing the concepts of: Don't repeat yourself(DRY). This means trying to write efficient code, using structures such as loops, to repeat the same commands. Functions. This is part of DRY. Troubleshooting errors. I think we needed to get started quicker. This worked better in the next session. Continued Code Club Turtle activities. We were one teacher down for this one in the later part of the session. Things worked better because we sat on a round table and I think it was easier to talk to everyone to get things working. I think we all got multiple stars drawing this time, with some people opting to use OSX, which was easier. Some things we looked at were: The basic idea that we our scripts are starting to have: An initialistion section. We set up things like variables here. This was easy to remember by talking about what happens when we don't reset our score when re-running a Scratch game. Function definitions. Main, which usually contains our commands or main loop that controls everything, and where we call functions we created. Functions. We looked at the ideas of: Built-in functions that come with Python Functions that we can import from modules User-defined functions that we define ourselves. Adding parameters to change how our user-defined functions work. An example of how we define our own Python function could be: def star (): for i in range ( 6 ): forward ( 100 ) right ( 120 ) Then this would give us a star() command that we could use to draw a star without typing all those lines. Later we looked at adding parameters so we could tell the function how big, or what colour to draw the star with. At a later stage we'll look at functions that can 'return' information to us when called. Using a Raspberry Pi computer and connecting with ssh and the OSX terminal, we examined, ran, and edited Python scripts to try and build a building in Minecraft Pi.","tags":"python","title":"Term 1 Python roundup"}]}